--- When missing element is accessed, gives an empty table
local createWhenAccessed = {
	__index = function(t,k)
		t[k] = {}
		return t[k]
	end
}

---@class resultsTable
---@field results table<tts__Player, any>
---@field handler function
---@field final function

--- A table of pending handlers, their results, and their 'final' callbacks.
--- Managed (except initial creation) from inside handlers.
---@type table<string, resultsTable>
local activeHandlers = setmetatable({}, createWhenAccessed)

---@param callback fun(handlerResults: table<tts__Player, any>)
---@return resultsTable
local function createResultsTable(handler, callback)
	local results = {}
	local function wrappedCallback()
		return callback(results)
	end
	return {handler = handler, results = results, callback = wrappedCallback}
end

--- A table of active handler names for each player that they can end manually.
--- Needs to be initialized from inside each handler! i.e. forward declared and inserted as a callback here
---@type table<tts__Player, table<string, true>>
local cancellable = { setmetatable({}, createWhenAccessed) }

--- Universal pass function. Exits from current passable prompt(s) for the given player with the current result-
--- not guaranteed to work if the function is meant to have mandatory input.
--- Uses any callbacks placed in the aforementioned `cancellable` table for that player.
---@param player tts__Player
local function pass(player)
	for handlerCallback in next(cancellable[Player[player]]) do
		handlerCallback()
	end
end
addHotkey("Pass", pass) -- here it's a hotkey but it could also be an xml button

-----@type function
--local inspect = require("IO/inspect")

-- todo: add event callback names into tts-types
--- Creates and a handler that will be called with every event trigger until its coroutine returns, then removed.
---@param event string
---@param name string
---@param co function | thread
---@param finally nil | function @A function to call after the coroutine is done.
---@return function @Returns the created/added handler
local function addCoroHandler(event, name, co, finally)
	if type(co) ~= "thread" then
		co = coroutine.create(co)
	end

	if coroutine.status(co) == "dead" then
		error("addCoroHandler(): stop stop he's already dead")
	end

	if activeHandlers[name] then
		error("addCoroHandler(): already have a handler with name " .. name)
	end

	local handler ---@type function

	handler = function(...)
		-- check if the coroutine has returned since last resume
		if coroutine.status(co) == "dead" then
			log("addCoroHandler(): the coroutine yielded while we weren't looking!")
			EventManager.removeHandler(event, handler)
			return
		end

		-- credit to sharpo https://discordapp.com/channels/561645196757041163/561645230672183310/724161820163833878
		local function check_and_call(cb, ok, ...)
			if ok then
				if coroutine.status(co) == "dead" then
					EventManager.removeHandler(event, handler)
					openHandlers[event][handler] = nil
					cb(...)
				end
			else
				error("addCoroHandler(): error in check_and_call: ") -- .. inspect({...}))
			end
		end
		check_and_call(finally, coroutine.resume(co))
	end

	activeHandlers[name] = createResultsTable(handler)
	EventManager.addHandler(event, handler)
	return handler
end

return { addCoroHandler = addCoroHandler, results = activeHandlers, cancellable = cancellable}
